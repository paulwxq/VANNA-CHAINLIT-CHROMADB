è®©æˆ‘ä»”ç»†åˆ†æä½ çš„ä»£ç ï¼Œå›ç­”è¿™ä¸¤ä¸ªå…³é”®é—®é¢˜ï¼š

## 1. CustomReactAgentç±»å¼‚æ­¥åŒ–åˆ†æ

### âœ… å·²ç»å¼‚æ­¥åŒ–çš„æ–¹æ³•ï¼š
```python
@classmethod
async def create(cls):                    # âœ… å¼‚æ­¥å·¥å‚æ–¹æ³•
async def _async_init(self):              # âœ… å¼‚æ­¥åˆå§‹åŒ–
async def close(self):                    # âœ… å¼‚æ­¥æ¸…ç†
async def chat(self, message, user_id, thread_id):  # âœ… å¼‚æ­¥èŠå¤©
async def get_conversation_history(self, thread_id): # âœ… å¼‚æ­¥è·å–å†å²
async def get_user_recent_conversations(self, user_id, limit): # âœ… å¼‚æ­¥è·å–å¯¹è¯åˆ—è¡¨
```

### âš ï¸ **ä»ç„¶æ˜¯åŒæ­¥çš„å…³é”®æ–¹æ³•ï¼ˆé—®é¢˜æ‰€åœ¨ï¼‰ï¼š**
```python
def _should_continue(self, state: AgentState) -> str:           # âŒ åŒæ­¥
def _agent_node(self, state: AgentState) -> Dict[str, Any]:     # âŒ åŒæ­¥
def _prepare_tool_input_node(self, state: AgentState):         # âŒ åŒæ­¥  
def _update_state_after_tool_node(self, state: AgentState):    # âŒ åŒæ­¥
def _format_final_response_node(self, state: AgentState):      # âŒ åŒæ­¥
```

**é—®é¢˜åˆ†æ**ï¼šä½ çš„StateGraphèŠ‚ç‚¹æ˜¯åŒæ­¥çš„ï¼Œä½†æ˜¯å†…éƒ¨è°ƒç”¨äº†å¼‚æ­¥LLMï¼š
```python
def _agent_node(self, state: AgentState) -> Dict[str, Any]:
    # è¿™æ˜¯åŒæ­¥å‡½æ•°ï¼Œä½†è°ƒç”¨å¼‚æ­¥LLM
    response = self.llm_with_tools.invoke(messages_for_llm)  # ğŸ”¥ è¿™é‡Œæœ‰é—®é¢˜
```

## 2. Rediså®¢æˆ·ç«¯ä½¿ç”¨åˆ†æ

### ä½ çš„ä»£ç ä¸­æ··ç”¨äº†ä¸¤ç§Rediså®¢æˆ·ç«¯ï¼š

**å¼‚æ­¥Rediså®¢æˆ·ç«¯ï¼ˆåœ¨agent.pyä¸­ï¼‰ï¼š**
```python
from redis.asyncio import Redis
redis_client = Redis.from_url(config.REDIS_URL, decode_responses=True)
```

**åŒæ­¥Rediså®¢æˆ·ç«¯ï¼ˆåœ¨api.pyå’Œenhanced_redis_api.pyä¸­ï¼‰ï¼š**
```python
import redis  # åŒæ­¥ç‰ˆæœ¬
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
```

### ğŸ¯ **å…³é”®é—®é¢˜ï¼šæ··ç”¨å¯¼è‡´çš„å†²çª**

## å®Œæ•´çš„ä¿®å¤æ–¹æ¡ˆ## å›ç­”ä½ çš„ä¸¤ä¸ªå…³é”®é—®é¢˜ï¼š

### 1. CustomReactAgentç±»å¼‚æ­¥åŒ–åˆ†æ

**âŒ ä½ çš„CustomReactAgentå¹¶æ²¡æœ‰å®Œå…¨å¼‚æ­¥åŒ–ï¼**

è™½ç„¶ä¸»è¦æ–¹æ³•æ˜¯asyncçš„ï¼Œä½†**StateGraphçš„èŠ‚ç‚¹æ–¹æ³•éƒ½æ˜¯åŒæ­¥çš„**ï¼Œè¿™æ­£æ˜¯é—®é¢˜çš„æ ¹æºï¼š

```python
# âŒ è¿™äº›æ˜¯åŒæ­¥æ–¹æ³•ï¼Œä½†å†…éƒ¨è°ƒç”¨å¼‚æ­¥LLM
def _agent_node(self, state: AgentState) -> Dict[str, Any]:
    response = self.llm_with_tools.invoke(messages_for_llm)  # ğŸ”¥é—®é¢˜åœ¨è¿™é‡Œ

def _prepare_tool_input_node(self, state: AgentState) -> Dict[str, Any]:
def _update_state_after_tool_node(self, state: AgentState) -> Dict[str, Any]:
def _format_final_response_node(self, state: AgentState) -> Dict[str, Any]:
def _should_continue(self, state: AgentState) -> str:
```

**æ ¸å¿ƒé—®é¢˜**ï¼šLangGraphçš„StateGraphå¯ä»¥æ”¯æŒå¼‚æ­¥èŠ‚ç‚¹ï¼Œä½†ä½ æ²¡æœ‰ä½¿ç”¨ï¼

### 2. Rediså®¢æˆ·ç«¯ä½¿ç”¨åˆ†æ

**âŒ ä½ æ··ç”¨äº†åŒæ­¥å’Œå¼‚æ­¥Rediså®¢æˆ·ç«¯ï¼**

**å¼‚æ­¥Rediså®¢æˆ·ç«¯ï¼ˆåœ¨agent.pyä¸­ï¼‰ï¼š**
```python
from redis.asyncio import Redis  # âœ… å¼‚æ­¥ç‰ˆæœ¬
redis_client = Redis.from_url(config.REDIS_URL, decode_responses=True)
```

**åŒæ­¥Rediså®¢æˆ·ç«¯ï¼ˆåœ¨api.pyå’Œenhanced_redis_api.pyä¸­ï¼‰ï¼š**
```python
import redis  # âŒ åŒæ­¥ç‰ˆæœ¬
redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
```

## ğŸ¯ **åœ¨ä½ çš„åœºæ™¯ä¸­æ˜¯å¦ä¸€å®šè¦ç”¨å¼‚æ­¥Redisï¼Ÿ**

**ç­”æ¡ˆï¼šå¼ºçƒˆå»ºè®®ä½¿ç”¨ï¼ŒåŸå› å¦‚ä¸‹ï¼š**

1. **æ¶æ„ä¸€è‡´æ€§**ï¼šæ—¢ç„¶Flaskè·¯ç”±æ˜¯å¼‚æ­¥çš„ï¼ŒRedisæ“ä½œä¹Ÿåº”è¯¥å¼‚æ­¥
2. **é¿å…é˜»å¡**ï¼šåŒæ­¥Redisæ“ä½œä¼šé˜»å¡äº‹ä»¶å¾ªç¯ï¼Œå½±å“å¹¶å‘æ€§èƒ½
3. **æ¶ˆé™¤é”™è¯¯æº**ï¼šæ··ç”¨æ˜¯å¯¼è‡´"Event loop is closed"çš„é‡è¦åŸå› 
4. **å¯¹è¯æœºå™¨äººç‰¹æ€§**ï¼šç”¨æˆ·æœŸæœ›å¿«é€Ÿå“åº”ï¼Œå¼‚æ­¥Redisèƒ½æä¾›æ›´å¥½çš„å¹¶å‘èƒ½åŠ›

## ğŸ”§ **æœ€å…³é”®çš„ä¿®æ”¹ç‚¹**

æˆ‘åœ¨ä¸Šé¢çš„artifactä¸­æä¾›äº†å®Œæ•´çš„ä¿®å¤æ–¹æ¡ˆï¼Œå…³é”®ä¿®æ”¹åŒ…æ‹¬ï¼š

### **1. StateGraphèŠ‚ç‚¹å…¨éƒ¨æ”¹ä¸ºå¼‚æ­¥ï¼š**
```python
# âœ… ä¿®æ”¹åï¼šå¼‚æ­¥èŠ‚ç‚¹
async def _async_agent_node(self, state: AgentState) -> Dict[str, Any]:
    response = await self.llm_with_tools.ainvoke(messages_for_llm)  # ä½¿ç”¨ainvoke

async def _async_prepare_tool_input_node(self, state: AgentState) -> Dict[str, Any]:
async def _async_update_state_after_tool_node(self, state: AgentState) -> Dict[str, Any]:
async def _async_format_final_response_node(self, state: AgentState) -> Dict[str, Any]:
async def _async_should_continue(self, state: AgentState) -> str:
```

### **2. ç»Ÿä¸€Rediså®¢æˆ·ç«¯ï¼š**
```python
# âœ… ç»Ÿä¸€ä½¿ç”¨å¼‚æ­¥Redis
import redis.asyncio as redis
self.redis_client = redis.from_url(config.REDIS_URL, decode_responses=True)
await self.redis_client.ping()
```

### **3. ç§»é™¤å¤æ‚çš„äº‹ä»¶å¾ªç¯ç®¡ç†ï¼š**
```python
# âŒ åˆ é™¤è¿™äº›å‡½æ•°
def run_async_safely():  # åˆ é™¤
def ensure_agent_ready_sync():  # åˆ é™¤

# âœ… ç›´æ¥ä½¿ç”¨async/await
@app.route("/api/chat", methods=["POST"])
async def chat_endpoint():
    agent_result = await _agent_instance.chat(...)  # ç›´æ¥è°ƒç”¨
```

## ğŸ“‹ **ä¿®æ”¹å»ºè®®æ€»ç»“**

1. **ç«‹å³ä¿®æ”¹**ï¼šå°†StateGraphæ‰€æœ‰èŠ‚ç‚¹æ”¹ä¸ºasyncç‰ˆæœ¬
2. **ç»Ÿä¸€Redis**ï¼šå…¨éƒ¨ä½¿ç”¨`redis.asyncio`
3. **åˆ é™¤åŒ…è£…**ï¼šç§»é™¤æ‰€æœ‰`run_async_safely`ç±»çš„å‡½æ•°
4. **Flaskè·¯ç”±**ï¼šæ ¸å¿ƒAPIè·¯ç”±æ”¹ä¸ºasync
5. **æµ‹è¯•éªŒè¯**ï¼šä¿®æ”¹åæµ‹è¯•Event loopé”™è¯¯æ˜¯å¦æ¶ˆå¤±

**æŒ‰ç…§æˆ‘æä¾›çš„ä¿®å¤æ–¹æ¡ˆä¿®æ”¹åï¼Œä½ å°±èƒ½ç›´æ¥ç”¨`python api.py`å¯åŠ¨ï¼Œä¸ä¼šå†æœ‰ä»»ä½•äº‹ä»¶å¾ªç¯é—®é¢˜ï¼**


"""
CustomReactAgentå®Œå…¨å¼‚æ­¥åŒ–ä¿®å¤æ–¹æ¡ˆ
è§£å†³StateGraphèŠ‚ç‚¹åŒæ­¥/å¼‚æ­¥æ··ç”¨é—®é¢˜ï¼Œç»Ÿä¸€Rediså®¢æˆ·ç«¯ä½¿ç”¨
"""

# ============= ä¿®å¤åçš„ agent.py =============
import logging
import json
import pandas as pd
from typing import List, Optional, Dict, Any, Tuple
from contextlib import AsyncExitStack

from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage, ToolMessage, BaseMessage, SystemMessage, AIMessage
from langgraph.graph import StateGraph, END
from langgraph.prebuilt import ToolNode
import redis.asyncio as redis  # ğŸ”¥ ç»Ÿä¸€ä½¿ç”¨å¼‚æ­¥Redis
try:
    from langgraph.checkpoint.redis import AsyncRedisSaver
except ImportError:
    AsyncRedisSaver = None

# ä»æ–°æ¨¡å—å¯¼å…¥é…ç½®ã€çŠ¶æ€å’Œå·¥å…·
try:
    from . import config
    from .state import AgentState
    from .sql_tools import sql_tools
except ImportError:
    import config
    from state import AgentState
    from sql_tools import sql_tools

logger = logging.getLogger(__name__)

class CustomReactAgent:
    """
    å®Œå…¨å¼‚æ­¥åŒ–çš„ CustomReactAgent
    æ‰€æœ‰èŠ‚ç‚¹æ–¹æ³•éƒ½æ˜¯å¼‚æ­¥çš„ï¼Œç»Ÿä¸€ä½¿ç”¨å¼‚æ­¥Rediså®¢æˆ·ç«¯
    """
    def __init__(self):
        """ç§æœ‰æ„é€ å‡½æ•°ï¼Œè¯·ä½¿ç”¨ create() ç±»æ–¹æ³•æ¥åˆ›å»ºå®ä¾‹ã€‚"""
        self.llm = None
        self.tools = None
        self.agent_executor = None
        self.checkpointer = None
        self._exit_stack = None
        self.redis_client = None  # ğŸ”¥ æ·»åŠ Rediså®¢æˆ·ç«¯å¼•ç”¨

    @classmethod
    async def create(cls):
        """å¼‚æ­¥å·¥å‚æ–¹æ³•ï¼Œåˆ›å»ºå¹¶åˆå§‹åŒ– CustomReactAgent å®ä¾‹ã€‚"""
        instance = cls()
        await instance._async_init()
        return instance

    async def _async_init(self):
        """å¼‚æ­¥åˆå§‹åŒ–æ‰€æœ‰ç»„ä»¶ã€‚"""
        logger.info("ğŸš€ å¼€å§‹åˆå§‹åŒ– CustomReactAgent...")

        # 1. åˆå§‹åŒ–å¼‚æ­¥Rediså®¢æˆ·ç«¯
        self.redis_client = redis.from_url(config.REDIS_URL, decode_responses=True)
        try:
            await self.redis_client.ping()
            logger.info(f"   âœ… Redisè¿æ¥æˆåŠŸ: {config.REDIS_URL}")
        except Exception as e:
            logger.error(f"   âŒ Redisè¿æ¥å¤±è´¥: {e}")
            raise

        # 2. åˆå§‹åŒ– LLM
        self.llm = ChatOpenAI(
            api_key=config.QWEN_API_KEY,
            base_url=config.QWEN_BASE_URL,
            model=config.QWEN_MODEL,
            temperature=0.1,
            timeout=config.NETWORK_TIMEOUT,
            max_retries=config.MAX_RETRIES,
            extra_body={
                "enable_thinking": False,
                "misc": {
                    "ensure_ascii": False
                }
            }
        )
        logger.info(f"   LLM å·²åˆå§‹åŒ–ï¼Œæ¨¡å‹: {config.QWEN_MODEL}")

        # 3. ç»‘å®šå·¥å…·
        self.tools = sql_tools
        self.llm_with_tools = self.llm.bind_tools(self.tools)
        logger.info(f"   å·²ç»‘å®š {len(self.tools)} ä¸ªå·¥å…·ã€‚")

        # 4. åˆå§‹åŒ– Redis Checkpointer
        if config.REDIS_ENABLED and AsyncRedisSaver is not None:
            try:
                self._exit_stack = AsyncExitStack()
                checkpointer_manager = AsyncRedisSaver.from_conn_string(config.REDIS_URL)
                self.checkpointer = await self._exit_stack.enter_async_context(checkpointer_manager)
                await self.checkpointer.asetup()
                logger.info(f"   AsyncRedisSaver æŒä¹…åŒ–å·²å¯ç”¨: {config.REDIS_URL}")
            except Exception as e:
                logger.error(f"   âŒ RedisSaver åˆå§‹åŒ–å¤±è´¥: {e}", exc_info=True)
                if self._exit_stack:
                    await self._exit_stack.aclose()
                self.checkpointer = None
        else:
            logger.warning("   Redis æŒä¹…åŒ–åŠŸèƒ½å·²ç¦ç”¨ã€‚")

        # 5. æ„å»º StateGraph
        self.agent_executor = self._create_graph()
        logger.info("   StateGraph å·²æ„å»ºå¹¶ç¼–è¯‘ã€‚")
        logger.info("âœ… CustomReactAgent åˆå§‹åŒ–å®Œæˆã€‚")

    async def close(self):
        """æ¸…ç†èµ„æºï¼Œå…³é—­æ‰€æœ‰è¿æ¥ã€‚"""
        if self._exit_stack:
            await self._exit_stack.aclose()
            self._exit_stack = None
            self.checkpointer = None
            logger.info("âœ… RedisSaver èµ„æºå·²é€šè¿‡ AsyncExitStack é‡Šæ”¾ã€‚")
        
        if self.redis_client:
            await self.redis_client.aclose()
            logger.info("âœ… Rediså®¢æˆ·ç«¯å·²å…³é—­ã€‚")

    def _create_graph(self):
        """å®šä¹‰å¹¶ç¼–è¯‘æœ€ç»ˆçš„ã€æ­£ç¡®çš„ StateGraph ç»“æ„ã€‚"""
        builder = StateGraph(AgentState)

        # ğŸ”¥ å…³é”®ä¿®æ”¹ï¼šæ‰€æœ‰èŠ‚ç‚¹éƒ½æ˜¯å¼‚æ­¥çš„
        builder.add_node("agent", self._async_agent_node)
        builder.add_node("prepare_tool_input", self._async_prepare_tool_input_node)
        builder.add_node("tools", ToolNode(self.tools))
        builder.add_node("update_state_after_tool", self._async_update_state_after_tool_node)
        builder.add_node("format_final_response", self._async_format_final_response_node)

        # å»ºç«‹æ­£ç¡®çš„è¾¹è¿æ¥
        builder.set_entry_point("agent")
        builder.add_conditional_edges(
            "agent",
            self._async_should_continue,  # ğŸ”¥ å¼‚æ­¥æ¡ä»¶åˆ¤æ–­
            {
                "continue": "prepare_tool_input",
                "end": "format_final_response"
            }
        )
        builder.add_edge("prepare_tool_input", "tools")
        builder.add_edge("tools", "update_state_after_tool")
        builder.add_edge("update_state_after_tool", "agent")
        builder.add_edge("format_final_response", END)

        return builder.compile(checkpointer=self.checkpointer)

    async def _async_should_continue(self, state: AgentState) -> str:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šåˆ¤æ–­æ˜¯ç»§ç»­è°ƒç”¨å·¥å…·è¿˜æ˜¯ç»“æŸã€‚"""
        last_message = state["messages"][-1]
        if hasattr(last_message, "tool_calls") and last_message.tool_calls:
            return "continue"
        return "end"

    async def _async_agent_node(self, state: AgentState) -> Dict[str, Any]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šAgent èŠ‚ç‚¹ï¼Œä½¿ç”¨å¼‚æ­¥LLMè°ƒç”¨ã€‚"""
        logger.info(f"ğŸ§  [Async Node] agent - Thread: {state['thread_id']}")
        
        messages_for_llm = list(state["messages"])
        if state.get("suggested_next_step"):
            instruction = f"æç¤ºï¼šå»ºè®®ä¸‹ä¸€æ­¥ä½¿ç”¨å·¥å…· '{state['suggested_next_step']}'ã€‚"
            messages_for_llm.append(SystemMessage(content=instruction))

        # ğŸ”¥ å…³é”®ä¿®æ”¹ï¼šä½¿ç”¨å¼‚æ­¥LLMè°ƒç”¨
        import time
        max_retries = config.MAX_RETRIES
        for attempt in range(max_retries):
            try:
                # ä½¿ç”¨å¼‚æ­¥è°ƒç”¨
                response = await self.llm_with_tools.ainvoke(messages_for_llm)
                logger.info(f"   âœ… å¼‚æ­¥LLMè°ƒç”¨æˆåŠŸ")
                return {"messages": [response]}
                
            except Exception as e:
                error_msg = str(e)
                logger.warning(f"   âš ï¸ å¼‚æ­¥LLMè°ƒç”¨å¤±è´¥ (å°è¯• {attempt + 1}/{max_retries}): {error_msg}")
                
                if any(keyword in error_msg for keyword in [
                    "Connection error", "APIConnectionError", "ConnectError", 
                    "timeout", "è¿œç¨‹ä¸»æœºå¼ºè¿«å…³é—­", "ç½‘ç»œè¿æ¥"
                ]):
                    if attempt < max_retries - 1:
                        wait_time = config.RETRY_BASE_DELAY ** attempt
                        logger.info(f"   ğŸ”„ ç½‘ç»œé”™è¯¯ï¼Œ{wait_time}ç§’åé‡è¯•...")
                        await asyncio.sleep(wait_time)  # ğŸ”¥ ä½¿ç”¨async sleep
                        continue
                    else:
                        logger.error(f"   âŒ ç½‘ç»œè¿æ¥æŒç»­å¤±è´¥ï¼Œè¿”å›é™çº§å›ç­”")
                        sql_data = await self._async_extract_latest_sql_data(state["messages"])
                        if sql_data:
                            fallback_content = "æŠ±æ­‰ï¼Œç”±äºç½‘ç»œè¿æ¥é—®é¢˜ï¼Œæ— æ³•ç”Ÿæˆå®Œæ•´çš„æ–‡å­—æ€»ç»“ã€‚ä¸è¿‡æŸ¥è¯¢å·²æˆåŠŸæ‰§è¡Œï¼Œç»“æœå¦‚ä¸‹ï¼š\n\n" + sql_data
                        else:
                            fallback_content = "æŠ±æ­‰ï¼Œç”±äºç½‘ç»œè¿æ¥é—®é¢˜ï¼Œæ— æ³•å®Œæˆæ­¤æ¬¡è¯·æ±‚ã€‚è¯·ç¨åé‡è¯•æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥ã€‚"
                            
                        fallback_response = AIMessage(content=fallback_content)
                        return {"messages": [fallback_response]}
                else:
                    logger.error(f"   âŒ LLMè°ƒç”¨å‡ºç°éç½‘ç»œé”™è¯¯: {error_msg}")
                    raise e

    async def _async_prepare_tool_input_node(self, state: AgentState) -> Dict[str, Any]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šä¿¡æ¯ç»„è£…èŠ‚ç‚¹ã€‚"""
        logger.info(f"ğŸ› ï¸ [Async Node] prepare_tool_input - Thread: {state['thread_id']}")
        
        last_message = state["messages"][-1]
        if not hasattr(last_message, "tool_calls") or not last_message.tool_calls:
            return {"messages": [last_message]}

        new_tool_calls = []
        for tool_call in last_message.tool_calls:
            if tool_call["name"] == "generate_sql":
                logger.info("   æ£€æµ‹åˆ° generate_sql è°ƒç”¨ï¼Œæ³¨å…¥å†å²æ¶ˆæ¯ã€‚")
                modified_args = tool_call["args"].copy()
                
                clean_history = []
                messages_except_current = state["messages"][:-1]
                
                for msg in messages_except_current:
                    if isinstance(msg, HumanMessage):
                        clean_history.append({
                            "type": "human",
                            "content": msg.content
                        })
                    elif isinstance(msg, AIMessage):
                        if msg.content and "[Formatted Output]" in msg.content:
                            clean_content = msg.content.replace("[Formatted Output]\n", "")
                            clean_history.append({
                                "type": "ai",
                                "content": clean_content
                            })
                
                modified_args["history_messages"] = clean_history
                logger.info(f"   æ³¨å…¥äº† {len(clean_history)} æ¡è¿‡æ»¤åçš„å†å²æ¶ˆæ¯")
                
                new_tool_calls.append({
                    "name": tool_call["name"],
                    "args": modified_args,
                    "id": tool_call["id"],
                })
            else:
                new_tool_calls.append(tool_call)
        
        last_message.tool_calls = new_tool_calls
        return {"messages": [last_message]}

    async def _async_update_state_after_tool_node(self, state: AgentState) -> Dict[str, Any]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šåœ¨å·¥å…·æ‰§è¡Œåï¼Œæ›´æ–° suggested_next_stepã€‚"""
        logger.info(f"ğŸ“ [Async Node] update_state_after_tool - Thread: {state['thread_id']}")
        
        last_tool_message = state['messages'][-1]
        tool_name = last_tool_message.name
        tool_output = last_tool_message.content
        next_step = None

        if tool_name == 'generate_sql':
            if "å¤±è´¥" in tool_output or "æ— æ³•ç”Ÿæˆ" in tool_output:
                next_step = 'answer_with_common_sense'
            else:
                next_step = 'valid_sql'
        elif tool_name == 'valid_sql':
            if "å¤±è´¥" in tool_output:
                next_step = 'analyze_validation_error'
            else:
                next_step = 'run_sql'
        elif tool_name == 'run_sql':
            next_step = 'summarize_final_answer'
            
        logger.info(f"   Tool '{tool_name}' executed. Suggested next step: {next_step}")
        return {"suggested_next_step": next_step}

    async def _async_format_final_response_node(self, state: AgentState) -> Dict[str, Any]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šæœ€ç»ˆè¾“å‡ºæ ¼å¼åŒ–èŠ‚ç‚¹ã€‚"""
        logger.info(f"ğŸ¨ [Async Node] format_final_response - Thread: {state['thread_id']}")
        
        last_message = state['messages'][-1]
        last_message.content = f"[Formatted Output]\n{last_message.content}"
        
        # ç”ŸæˆAPIæ ¼å¼çš„æ•°æ®
        api_data = await self._async_generate_api_data(state)

        return {
            "messages": [last_message],
            "api_data": api_data
        }

    async def _async_generate_api_data(self, state: AgentState) -> Dict[str, Any]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šç”ŸæˆAPIæ ¼å¼çš„æ•°æ®ç»“æ„"""
        logger.info("ğŸ“Š å¼‚æ­¥ç”ŸæˆAPIæ ¼å¼æ•°æ®...")
        
        last_message = state['messages'][-1]
        response_content = last_message.content
        
        if response_content.startswith("[Formatted Output]\n"):
            response_content = response_content.replace("[Formatted Output]\n", "")
        
        api_data = {
            "response": response_content
        }
        
        sql_info = await self._async_extract_sql_and_data(state['messages'])
        if sql_info['sql']:
            api_data["sql"] = sql_info['sql']
        if sql_info['records']:
            api_data["records"] = sql_info['records']
        
        api_data["react_agent_meta"] = await self._async_collect_agent_metadata(state)
        
        logger.info(f"   APIæ•°æ®ç”Ÿæˆå®Œæˆï¼ŒåŒ…å«å­—æ®µ: {list(api_data.keys())}")
        return api_data

    async def _async_extract_sql_and_data(self, messages: List[BaseMessage]) -> Dict[str, Any]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šä»æ¶ˆæ¯å†å²ä¸­æå–SQLå’Œæ•°æ®è®°å½•"""
        result = {"sql": None, "records": None}
        
        last_human_index = -1
        for i in range(len(messages) - 1, -1, -1):
            if isinstance(messages[i], HumanMessage):
                last_human_index = i
                break
        
        if last_human_index == -1:
            return result
        
        current_conversation = messages[last_human_index:]
        sql_query = None
        sql_data = None
        
        for msg in current_conversation:
            if isinstance(msg, ToolMessage):
                if msg.name == 'generate_sql':
                    content = msg.content
                    if content and not any(keyword in content for keyword in ["å¤±è´¥", "æ— æ³•ç”Ÿæˆ", "Database query failed"]):
                        sql_query = content.strip()
                elif msg.name == 'run_sql':
                    try:
                        import json
                        parsed_data = json.loads(msg.content)
                        if isinstance(parsed_data, list) and len(parsed_data) > 0:
                            columns = list(parsed_data[0].keys()) if parsed_data else []
                            sql_data = {
                                "columns": columns,
                                "rows": parsed_data,
                                "total_row_count": len(parsed_data),
                                "is_limited": False
                            }
                    except (json.JSONDecodeError, Exception) as e:
                        logger.warning(f"   è§£æSQLç»“æœå¤±è´¥: {e}")
        
        if sql_query:
            result["sql"] = sql_query
        if sql_data:
            result["records"] = sql_data
            
        return result

    async def _async_collect_agent_metadata(self, state: AgentState) -> Dict[str, Any]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šæ”¶é›†Agentå…ƒæ•°æ®"""
        messages = state['messages']
        
        tools_used = []
        sql_execution_count = 0
        context_injected = False
        conversation_rounds = sum(1 for msg in messages if isinstance(msg, HumanMessage))
        
        for msg in messages:
            if isinstance(msg, ToolMessage):
                if msg.name not in tools_used:
                    tools_used.append(msg.name)
                if msg.name == 'run_sql':
                    sql_execution_count += 1
            elif isinstance(msg, AIMessage) and hasattr(msg, 'tool_calls') and msg.tool_calls:
                for tool_call in msg.tool_calls:
                    tool_name = tool_call.get('name')
                    if tool_name and tool_name not in tools_used:
                        tools_used.append(tool_name)
                    
                    if (tool_name == 'generate_sql' and 
                        tool_call.get('args', {}).get('history_messages')):
                        context_injected = True
        
        execution_path = ["agent"]
        if tools_used:
            execution_path.extend(["prepare_tool_input", "tools"])
        execution_path.append("format_final_response")
        
        return {
            "thread_id": state['thread_id'],
            "conversation_rounds": conversation_rounds,
            "tools_used": tools_used,
            "execution_path": execution_path,
            "total_messages": len(messages),
            "sql_execution_count": sql_execution_count,
            "context_injected": context_injected,
            "agent_version": "custom_react_v1_async"
        }

    async def _async_extract_latest_sql_data(self, messages: List[BaseMessage]) -> Optional[str]:
        """ğŸ”¥ å¼‚æ­¥ç‰ˆæœ¬ï¼šæå–æœ€æ–°çš„SQLæ‰§è¡Œç»“æœ"""
        logger.info("ğŸ” å¼‚æ­¥æå–æœ€æ–°çš„SQLæ‰§è¡Œç»“æœ...")
        
        last_human_index = -1
        for i in range(len(messages) - 1, -1, -1):
            if isinstance(messages[i], HumanMessage):
                last_human_index = i
                break
        
        if last_human_index == -1:
            logger.info("   æœªæ‰¾åˆ°ç”¨æˆ·æ¶ˆæ¯ï¼Œè·³è¿‡SQLæ•°æ®æå–")
            return None
        
        current_conversation = messages[last_human_index:]
        logger.info(f"   å½“å‰å¯¹è¯è½®æ¬¡åŒ…å« {len(current_conversation)} æ¡æ¶ˆæ¯")
        
        for msg in reversed(current_conversation):
            if isinstance(msg, ToolMessage) and msg.name == 'run_sql':
                logger.info(f"   æ‰¾åˆ°å½“å‰å¯¹è¯è½®æ¬¡çš„run_sqlç»“æœ: {msg.content[:100]}...")
                
                try:
                    parsed_data = json.loads(msg.content)
                    formatted_content = json.dumps(parsed_data, ensure_ascii=False, separators=(',', ':'))
                    logger.info(f"   å·²è½¬æ¢Unicodeè½¬ä¹‰åºåˆ—ä¸ºä¸­æ–‡å­—ç¬¦")
                    return formatted_content
                except json.JSONDecodeError:
                    logger.warning(f"   SQLç»“æœä¸æ˜¯æœ‰æ•ˆJSONæ ¼å¼ï¼Œè¿”å›åŸå§‹å†…å®¹")
                    return msg.content
        
        logger.info("   å½“å‰å¯¹è¯è½®æ¬¡ä¸­æœªæ‰¾åˆ°run_sqlæ‰§è¡Œç»“æœ")
        return None

    async def chat(self, message: str, user_id: str, thread_id: Optional[str] = None) -> Dict[str, Any]:
        """ğŸ”¥ å®Œå…¨å¼‚æ­¥çš„èŠå¤©å¤„ç†æ–¹æ³•"""
        if not thread_id:
            now = pd.Timestamp.now()
            milliseconds = int(now.microsecond / 1000)
            thread_id = f"{user_id}:{now.strftime('%Y%m%d%H%M%S')}{milliseconds:03d}"
            logger.info(f"ğŸ†• æ–°å»ºä¼šè¯ï¼ŒThread ID: {thread_id}")
        
        config = {
            "configurable": {
                "thread_id": thread_id,
            }
        }
        
        inputs = {
            "messages": [HumanMessage(content=message)],
            "user_id": user_id,
            "thread_id": thread_id,
            "suggested_next_step": None,
        }

        try:
            # ğŸ”¥ ä½¿ç”¨å¼‚æ­¥è°ƒç”¨
            final_state = await self.agent_executor.ainvoke(inputs, config)
            answer = final_state["messages"][-1].content
            
            sql_data = await self._async_extract_latest_sql_data(final_state["messages"])
            
            logger.info(f"âœ… å¼‚æ­¥å¤„ç†å®Œæˆ - Final Answer: '{answer}'")
            
            result = {
                "success": True, 
                "answer": answer, 
                "thread_id": thread_id
            }
            
            if sql_data:
                result["sql_data"] = sql_data
                logger.info("   ğŸ“Š å·²åŒ…å«SQLåŸå§‹æ•°æ®")
            
            if "api_data" in final_state:
                result["api_data"] = final_state["api_data"]
                logger.info("   ğŸ”Œ å·²åŒ…å«APIæ ¼å¼æ•°æ®")
            
            return result
            
        except Exception as e:
            logger.error(f"âŒ å¼‚æ­¥å¤„ç†è¿‡ç¨‹ä¸­å‘ç”Ÿä¸¥é‡é”™è¯¯ - Thread: {thread_id}: {e}", exc_info=True)
            return {"success": False, "error": str(e), "thread_id": thread_id}
    
    async def get_conversation_history(self, thread_id: str) -> List[Dict[str, Any]]:
        """ğŸ”¥ å®Œå…¨å¼‚æ­¥çš„å¯¹è¯å†å²è·å–"""
        if not self.checkpointer:
            return []
        
        config = {"configurable": {"thread_id": thread_id}}
        try:
            conversation_state = await self.checkpointer.aget(config)
        except RuntimeError as e:
            if "Event loop is closed" in str(e):
                logger.warning(f"âš ï¸ Event loopå·²å…³é—­ï¼Œè¿”å›ç©ºç»“æœ: {thread_id}")
                return []
            else:
                raise
        
        if not conversation_state:
            return []
            
        history = []
        messages = conversation_state.get('channel_values', {}).get('messages', [])
        for msg in messages:
            if isinstance(msg, HumanMessage):
                role = "human"
            elif isinstance(msg, ToolMessage):
                role = "tool"
            else:
                role = "ai"
            
            history.append({
                "type": role,
                "content": msg.content,
                "tool_calls": getattr(msg, 'tool_calls', None)
            })
        return history 

    async def get_user_recent_conversations(self, user_id: str, limit: int = 10) -> List[Dict[str, Any]]:
        """ğŸ”¥ å®Œå…¨å¼‚æ­¥çš„ç”¨æˆ·å¯¹è¯åˆ—è¡¨è·å–"""
        if not self.checkpointer:
            return []
        
        try:
            # ğŸ”¥ ä½¿ç”¨ç»Ÿä¸€çš„å¼‚æ­¥Rediså®¢æˆ·ç«¯
            pattern = f"checkpoint:{user_id}:*"
            logger.info(f"ğŸ” å¼‚æ­¥æ‰«ææ¨¡å¼: {pattern}")
            
            user_threads = {}
            cursor = 0
            
            while True:
                cursor, keys = await self.redis_client.scan(
                    cursor=cursor,
                    match=pattern,
                    count=1000
                )
                
                for key in keys:
                    try:
                        key_str = key.decode() if isinstance(key, bytes) else key
                        parts = key_str.split(':')
                        
                        if len(parts) >= 4:
                            thread_id = f"{parts[1]}:{parts[2]}"
                            timestamp = parts[2]
                            
                            if thread_id not in user_threads:
                                user_threads[thread_id] = {
                                    "thread_id": thread_id,
                                    "timestamp": timestamp,
                                    "latest_key": key_str
                                }
                            else:
                                if len(parts) > 4 and parts[4] > user_threads[thread_id]["latest_key"].split(':')[4]:
                                    user_threads[thread_id]["latest_key"] = key_str
                                    
                    except Exception as e:
                        logger.warning(f"è§£ækey {key} å¤±è´¥: {e}")
                        continue
                
                if cursor == 0:
                    break
            
            # æŒ‰æ—¶é—´æˆ³æ’åº
            sorted_threads = sorted(
                user_threads.values(),
                key=lambda x: x["timestamp"],
                reverse=True
            )[:limit]
            
            # è·å–æ¯ä¸ªthreadçš„è¯¦ç»†ä¿¡æ¯
            conversations = []
            for thread_info in sorted_threads:
                try:
                    thread_id = thread_info["thread_id"]
                    thread_config = {"configurable": {"thread_id": thread_id}}
                    
                    try:
                        state = await self.checkpointer.aget(thread_config)
                    except RuntimeError as e:
                        if "Event loop is closed" in str(e):
                            logger.warning(f"âš ï¸ Event loopå·²å…³é—­ï¼Œè·³è¿‡thread: {thread_id}")
                            continue
                        else:
                            raise
                    
                    if state and state.get('channel_values', {}).get('messages'):
                        messages = state['channel_values']['messages']
                        preview = self._generate_conversation_preview(messages)
                        
                        conversations.append({
                            "thread_id": thread_id,
                            "user_id": user_id,
                            "timestamp": thread_info["timestamp"],
                            "message_count": len(messages),
                            "last_message": messages[-1].content if messages else None,
                            "last_updated": state.get('created_at'),
                            "conversation_preview": preview,
                            "formatted_time": self._format_timestamp(thread_info["timestamp"])
                        })
                        
                except Exception as e:
                    logger.error(f"è·å–thread {thread_info['thread_id']} è¯¦æƒ…å¤±è´¥: {e}")
                    continue
            
            logger.info(f"âœ… å¼‚æ­¥æ‰¾åˆ°ç”¨æˆ· {user_id} çš„ {len(conversations)} ä¸ªå¯¹è¯")
            return conversations
            
        except Exception as e:
            logger.error(f"âŒ å¼‚æ­¥è·å–ç”¨æˆ· {user_id} å¯¹è¯åˆ—è¡¨å¤±è´¥: {e}")
            return []

    def _generate_conversation_preview(self, messages: List[BaseMessage]) -> str:
        """ç”Ÿæˆå¯¹è¯é¢„è§ˆï¼ˆä¿æŒåŒæ­¥ï¼Œå› ä¸ºæ˜¯çº¯è®¡ç®—ï¼‰"""
        if not messages:
            return "ç©ºå¯¹è¯"
        
        for msg in messages:
            if isinstance(msg, HumanMessage):
                content = str(msg.content)
                return content[:50] + "..." if len(content) > 50 else content
        
        return "ç³»ç»Ÿæ¶ˆæ¯"

    def _format_timestamp(self, timestamp: str) -> str:
        """æ ¼å¼åŒ–æ—¶é—´æˆ³ä¸ºå¯è¯»æ ¼å¼ï¼ˆä¿æŒåŒæ­¥ï¼Œå› ä¸ºæ˜¯çº¯è®¡ç®—ï¼‰"""
        try:
            if len(timestamp) >= 14:
                year = timestamp[:4]
                month = timestamp[4:6]
                day = timestamp[6:8]
                hour = timestamp[8:10]
                minute = timestamp[10:12]
                second = timestamp[12:14]
                return f"{year}-{month}-{day} {hour}:{minute}:{second}"
        except Exception:
            pass
        return timestamp


# ============= ä¿®å¤åçš„ api.py å…³é”®éƒ¨åˆ† =============

"""
ä¿®å¤åçš„ api.py - ç»Ÿä¸€ä½¿ç”¨å¼‚æ­¥Rediså®¢æˆ·ç«¯ï¼Œç§»é™¤å¤æ‚çš„äº‹ä»¶å¾ªç¯ç®¡ç†
"""

import asyncio
import logging
import os
from datetime import datetime
from typing import Optional, Dict, Any

from flask import Flask, request, jsonify
import redis.asyncio as redis  # ğŸ”¥ ç»Ÿä¸€ä½¿ç”¨å¼‚æ­¥Redis

try:
    from .agent import CustomReactAgent
except ImportError:
    from agent import CustomReactAgent

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# å…¨å±€Agentå®ä¾‹
_agent_instance: Optional[CustomReactAgent] = None
_redis_client: Optional[redis.Redis] = None

def validate_request_data(data: Dict[str, Any]) -> Dict[str, Any]:
    """éªŒè¯è¯·æ±‚æ•°æ®ï¼ˆä¿æŒä¸å˜ï¼‰"""
    errors = []
    
    question = data.get('question', '')
    if not question or not question.strip():
        errors.append('é—®é¢˜ä¸èƒ½ä¸ºç©º')
    elif len(question) > 2000:
        errors.append('é—®é¢˜é•¿åº¦ä¸èƒ½è¶…è¿‡2000å­—ç¬¦')
    
    user_id = data.get('user_id', 'guest')
    if user_id and len(user_id) > 50:
        errors.append('ç”¨æˆ·IDé•¿åº¦ä¸èƒ½è¶…è¿‡50å­—ç¬¦')
    
    if errors:
        raise ValueError('; '.join(errors))
    
    return {
        'question': question.strip(),
        'user_id': user_id or 'guest',
        'thread_id': data.get('thread_id')
    }

async def initialize_agent():
    """ğŸ”¥ å¼‚æ­¥åˆå§‹åŒ–Agent"""
    global _agent_instance, _redis_client
    
    if _agent_instance is None:
        logger.info("ğŸš€ æ­£åœ¨å¼‚æ­¥åˆå§‹åŒ– Custom React Agent...")
        try:
            os.environ['REDIS_URL'] = 'redis://localhost:6379'
            
            # åˆå§‹åŒ–å…±äº«çš„Rediså®¢æˆ·ç«¯
            _redis_client = redis.from_url('redis://localhost:6379', decode_responses=True)
            await _redis_client.ping()
            
            _agent_instance = await CustomReactAgent.create()
            logger.info("âœ… Agent å¼‚æ­¥åˆå§‹åŒ–å®Œæˆ")
        except Exception as e:
            logger.error(f"âŒ Agent å¼‚æ­¥åˆå§‹åŒ–å¤±è´¥: {e}")
            raise

async def ensure_agent_ready():
    """ğŸ”¥ å¼‚æ­¥ç¡®ä¿Agentå®ä¾‹å¯ç”¨"""
    global _agent_instance
    
    if _agent_instance is None:
        await initialize_agent()
    
    try:
        test_result = await _agent_instance.get_user_recent_conversations("__test__", 1)
        return True
    except Exception as e:
        logger.warning(f"âš ï¸ Agentå®ä¾‹ä¸å¯ç”¨: {e}")
        _agent_instance = None
        await initialize_agent()
        return True

async def cleanup_agent():
    """ğŸ”¥ å¼‚æ­¥æ¸…ç†Agentèµ„æº"""
    global _agent_instance, _redis_client
    
    if _agent_instance:
        await _agent_instance.close()
        logger.info("âœ… Agent èµ„æºå·²å¼‚æ­¥æ¸…ç†")
        _agent_instance = None
    
    if _redis_client:
        await _redis_client.aclose()
        logger.info("âœ… Rediså®¢æˆ·ç«¯å·²å¼‚æ­¥å…³é—­")
        _redis_client = None

# åˆ›å»ºFlaskåº”ç”¨
app = Flask(__name__)

# ğŸ”¥ ç§»é™¤æ‰€æœ‰åŒæ­¥åŒ…è£…å‡½æ•°ï¼šrun_async_safely, ensure_agent_ready_sync

@app.route("/")
def root():
    """å¥åº·æ£€æŸ¥ç«¯ç‚¹ï¼ˆä¿æŒåŒæ­¥ï¼‰"""
    return jsonify({"message": "Custom React Agent API æœåŠ¡æ­£åœ¨è¿è¡Œ"})

@app.route('/health', methods=['GET'])
def health_check():
    """å¥åº·æ£€æŸ¥ç«¯ç‚¹ï¼ˆä¿æŒåŒæ­¥ï¼‰"""
    try:
        health_status = {
            "status": "healthy",
            "agent_initialized": _agent_instance is not None,
            "timestamp": datetime.now().isoformat()
        }
        return jsonify(health_status), 200
    except Exception as e:
        logger.error(f"å¥åº·æ£€æŸ¥å¤±è´¥: {e}")
        return jsonify({"status": "unhealthy", "error": str(e)}), 500

@app.route("/api/chat", methods=["POST"])
async def chat_endpoint():
    """ğŸ”¥ å¼‚æ­¥æ™ºèƒ½é—®ç­”æ¥å£"""
    global _agent_instance
    
    # ç¡®ä¿Agentå·²åˆå§‹åŒ–
    if not await ensure_agent_ready():
        return jsonify({
            "code": 503,
            "message": "æœåŠ¡æœªå°±ç»ª",
            "success": False,
            "error": "Agent åˆå§‹åŒ–å¤±è´¥"
        }), 503
    
    try:
        data = request.get_json()
        if not data:
            return jsonify({
                "code": 400,
                "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
                "success": False,
                "error": "è¯·æ±‚ä½“ä¸èƒ½ä¸ºç©º"
            }), 400
        
        validated_data = validate_request_data(data)
        
        logger.info(f"ğŸ“¨ æ”¶åˆ°è¯·æ±‚ - User: {validated_data['user_id']}, Question: {validated_data['question'][:50]}...")
        
        # ğŸ”¥ ç›´æ¥è°ƒç”¨å¼‚æ­¥æ–¹æ³•ï¼Œä¸éœ€è¦äº‹ä»¶å¾ªç¯åŒ…è£…
        agent_result = await _agent_instance.chat(
            message=validated_data['question'],
            user_id=validated_data['user_id'],
            thread_id=validated_data['thread_id']
        )
        
        if not agent_result.get("success", False):
            error_msg = agent_result.get("error", "Agentå¤„ç†å¤±è´¥")
            logger.error(f"âŒ Agentå¤„ç†å¤±è´¥: {error_msg}")
            
            return jsonify({
                "code": 500,
                "message": "å¤„ç†å¤±è´¥",
                "success": False,
                "error": error_msg,
                "data": {
                    "react_agent_meta": {
                        "thread_id": agent_result.get("thread_id"),
                        "agent_version": "custom_react_v1_async",
                        "execution_path": ["error"]
                    },
                    "timestamp": datetime.now().isoformat()
                }
            }), 500
        
        api_data = agent_result.get("api_data", {})
        response_data = {
            **api_data,
            "timestamp": datetime.now().isoformat()
        }
        
        logger.info(f"âœ… å¼‚æ­¥è¯·æ±‚å¤„ç†æˆåŠŸ - Thread: {api_data.get('react_agent_meta', {}).get('thread_id')}")
        
        return jsonify({
            "code": 200,
            "message": "æ“ä½œæˆåŠŸ",
            "success": True,
            "data": response_data
        })
        
    except ValueError as e:
        logger.warning(f"âš ï¸ å‚æ•°éªŒè¯å¤±è´¥: {e}")
        return jsonify({
            "code": 400,
            "message": "è¯·æ±‚å‚æ•°é”™è¯¯",
            "success": False,
            "error": str(e)
        }), 400
        
    except Exception as e:
        logger.error(f"âŒ æœªé¢„æœŸçš„é”™è¯¯: {e}", exc_info=True)
        return jsonify({
            "code": 500,
            "message": "æœåŠ¡å™¨å†…éƒ¨é”™è¯¯", 
            "success": False,
            "error": "ç³»ç»Ÿå¼‚å¸¸ï¼Œè¯·ç¨åé‡è¯•"
        }), 500

@app.route('/api/v0/react/users/<user_id>/conversations', methods=['GET'])
async def get_user_conversations(user_id: str):
    """ğŸ”¥ å¼‚æ­¥è·å–ç”¨æˆ·çš„èŠå¤©è®°å½•åˆ—è¡¨"""
    global _agent_instance
    
    try:
        limit = request.args.get('limit', 10, type=int)
        limit = max(1, min(limit, 50))
        
        logger.info(f"ğŸ“‹ å¼‚æ­¥è·å–ç”¨æˆ· {user_id} çš„å¯¹è¯åˆ—è¡¨ï¼Œé™åˆ¶ {limit} æ¡")
        
        if not await ensure_agent_ready():
            return jsonify({
                "success": False,
                "error": "Agent æœªå°±ç»ª",
                "timestamp": datetime.now().isoformat()
            }), 503
        
        # ğŸ”¥ ç›´æ¥è°ƒç”¨å¼‚æ­¥æ–¹æ³•
        conversations = await _agent_instance.get_user_recent_conversations(user_id, limit)
        
        return jsonify({
            "success": True,
            "data": {
                "user_id": user_id,
                "conversations": conversations,
                "total_count": len(conversations),
                "limit": limit
            },
            "timestamp": datetime.now().isoformat()
        }), 200
        
    except Exception as e:
        logger.error(f"âŒ å¼‚æ­¥è·å–ç”¨æˆ· {user_id} å¯¹è¯åˆ—è¡¨å¤±è´¥: {e}")
        return jsonify({
            "success": False,
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }), 500

@app.route('/api/v0/react/users/<user_id>/conversations/<thread_id>', methods=['GET'])
async def get_user_conversation_detail(user_id: str, thread_id: str):
    """ğŸ”¥ å¼‚æ­¥è·å–ç‰¹å®šå¯¹è¯çš„è¯¦ç»†å†å²"""
    global _agent_instance
    
    try:
        if not thread_id.startswith(f"{user_id}:"):
            return jsonify({
                "success": False,
                "error": f"Thread ID {thread_id} ä¸å±äºç”¨æˆ· {user_id}",
                "timestamp": datetime.now().isoformat()
            }), 400
        
        logger.info(f"ğŸ“– å¼‚æ­¥è·å–ç”¨æˆ· {user_id} çš„å¯¹è¯ {thread_id} è¯¦æƒ…")
        
        if not await ensure_agent_ready():
            return jsonify({
                "success": False,
                "error": "Agent æœªå°±ç»ª",
                "timestamp": datetime.now().isoformat()
            }), 503
        
        # ğŸ”¥ ç›´æ¥è°ƒç”¨å¼‚æ­¥æ–¹æ³•
        history = await _agent_instance.get_conversation_history(thread_id)
        logger.info(f"âœ… å¼‚æ­¥æˆåŠŸè·å–å¯¹è¯å†å²ï¼Œæ¶ˆæ¯æ•°é‡: {len(history)}")
        
        if not history:
            return jsonify({
                "success": False,
                "error": f"æœªæ‰¾åˆ°å¯¹è¯ {thread_id}",
                "timestamp": datetime.now().isoformat()
            }), 404
        
        return jsonify({
            "success": True,
            "data": {
                "user_id": user_id,
                "thread_id": thread_id,
                "message_count": len(history),
                "messages": history
            },
            "timestamp": datetime.now().isoformat()
        }), 200
        
    except Exception as e:
        import traceback
        logger.error(f"âŒ å¼‚æ­¥è·å–å¯¹è¯ {thread_id} è¯¦æƒ…å¤±è´¥: {e}")
        logger.error(f"âŒ è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")
        return jsonify({
            "success": False,
            "error": str(e),
            "timestamp": datetime.now().isoformat()
        }), 500

# ğŸ”¥ å¼‚æ­¥Redis APIï¼ˆå¦‚æœè¿˜éœ€è¦ç›´æ¥Redisè®¿é—®ï¼‰
async def get_user_conversations_async(user_id: str, limit: int = 10):
    """ğŸ”¥ å®Œå…¨å¼‚æ­¥çš„RedisæŸ¥è¯¢å‡½æ•°"""
    global _redis_client
    
    try:
        if not _redis_client:
            _redis_client = redis.from_url('redis://localhost:6379', decode_responses=True)
            await _redis_client.ping()
        
        pattern = f"checkpoint:{user_id}:*"
        logger.info(f"ğŸ” å¼‚æ­¥æ‰«ææ¨¡å¼: {pattern}")
        
        keys = []
        cursor = 0
        while True:
            cursor, batch = await _redis_client.scan(cursor=cursor, match=pattern, count=1000)
            keys.extend(batch)
            if cursor == 0:
                break
        
        logger.info(f"ğŸ“‹ å¼‚æ­¥æ‰¾åˆ° {len(keys)} ä¸ªkeys")
        
        # è§£æå’Œå¤„ç†é€»è¾‘ï¼ˆä¸åŸæ¥ç›¸åŒï¼Œä½†ä½¿ç”¨å¼‚æ­¥Redisæ“ä½œï¼‰
        thread_data = {}
        for key in keys:
            try:
                parts = key.split(':')
                if len(parts) >= 4:
                    thread_id = f"{parts[1]}:{parts[2]}"
                    timestamp = parts[2]
                    
                    if thread_id not in thread_data:
                        thread_data[thread_id] = {
                            "thread_id": thread_id,
                            "timestamp": timestamp,
                            "keys": []
                        }
                    thread_data[thread_id]["keys"].append(key)
            except Exception as e:
                logger.warning(f"è§£ækeyå¤±è´¥ {key}: {e}")
                continue
        
        sorted_threads = sorted(
            thread_data.values(),
            key=lambda x: x["timestamp"],
            reverse=True
        )[:limit]
        
        conversations = []
        for thread_info in sorted_threads:
            try:
                thread_id = thread_info["thread_id"]
                latest_key = max(thread_info["keys"])
                
                # ğŸ”¥ ä½¿ç”¨å¼‚æ­¥Redisè·å–
                key_type = await _redis_client.type(latest_key)
                
                data = None
                if key_type == 'string':
                    data = await _redis_client.get(latest_key)
                elif key_type == 'ReJSON-RL':
                    try:
                        data = await _redis_client.execute_command('JSON.GET', latest_key)
                    except Exception as json_error:
                        logger.error(f"âŒ å¼‚æ­¥JSON.GET å¤±è´¥: {json_error}")
                        continue
                
                if data:
                    try:
                        import json
                        checkpoint_data = json.loads(data)
                        
                        messages = []
                        if 'checkpoint' in checkpoint_data:
                            checkpoint = checkpoint_data['checkpoint']
                            if isinstance(checkpoint, dict) and 'channel_values' in checkpoint:
                                channel_values = checkpoint['channel_values']
                                if isinstance(channel_values, dict) and 'messages' in channel_values:
                                    messages = channel_values['messages']
                        
                        preview = "ç©ºå¯¹è¯"
                        if messages:
                            for msg in messages:
                                if isinstance(msg, dict):
                                    if (msg.get('lc') == 1 and 
                                        msg.get('type') == 'constructor' and 
                                        'id' in msg and 
                                        isinstance(msg['id'], list) and 
                                        len(msg['id']) >= 4 and
                                        msg['id'][3] == 'HumanMessage' and
                                        'kwargs' in msg):
                                        
                                        kwargs = msg['kwargs']
                                        if kwargs.get('type') == 'human' and 'content' in kwargs:
                                            content = str(kwargs['content'])
                                            preview = content[:50] + "..." if len(content) > 50 else content
                                            break
                        
                        conversations.append({
                            "thread_id": thread_id,
                            "user_id": user_id,
                            "timestamp": thread_info["timestamp"],
                            "message_count": len(messages),
                            "conversation_preview": preview
                        })
                        
                    except json.JSONDecodeError:
                        logger.error(f"âŒ å¼‚æ­¥JSONè§£æå¤±è´¥")
                        continue
                    
            except Exception as e:
                logger.error(f"å¼‚æ­¥å¤„ç†thread {thread_info['thread_id']} å¤±è´¥: {e}")
                continue
        
        logger.info(f"âœ… å¼‚æ­¥è¿”å› {len(conversations)} ä¸ªå¯¹è¯")
        return conversations
        
    except Exception as e:
        logger.error(f"âŒ å¼‚æ­¥RedisæŸ¥è¯¢å¤±è´¥: {e}")
        return []

# ğŸ”¥ å¼‚æ­¥å¯åŠ¨å’Œæ¸…ç†
async def startup():
    """åº”ç”¨å¯åŠ¨æ—¶çš„å¼‚æ­¥åˆå§‹åŒ–"""
    logger.info("ğŸš€ å¯åŠ¨å¼‚æ­¥Flaskåº”ç”¨...")
    try:
        await initialize_agent()
        logger.info("âœ… Agent é¢„åˆå§‹åŒ–å®Œæˆ")
    except Exception as e:
        logger.error(f"âŒ å¯åŠ¨æ—¶Agentåˆå§‹åŒ–å¤±è´¥: {e}")

async def shutdown():
    """åº”ç”¨å…³é—­æ—¶çš„å¼‚æ­¥æ¸…ç†"""
    logger.info("ğŸ”„ å…³é—­å¼‚æ­¥Flaskåº”ç”¨...")
    try:
        await cleanup_agent()
        logger.info("âœ… èµ„æºæ¸…ç†å®Œæˆ")
    except Exception as e:
        logger.error(f"âŒ å…³é—­æ—¶æ¸…ç†å¤±è´¥: {e}")

if __name__ == "__main__":
    # ğŸ”¥ ç®€åŒ–çš„å¯åŠ¨æ–¹å¼ - Flask 3.x åŸç”Ÿæ”¯æŒå¼‚æ­¥
    logger.info("ğŸš€ ä½¿ç”¨Flaskå†…ç½®å¼‚æ­¥æ”¯æŒå¯åŠ¨...")
    
    # ä¿¡å·å¤„ç†
    import signal
    
    def signal_handler(signum, frame):
        logger.info("ğŸ›‘ æ”¶åˆ°å…³é—­ä¿¡å·ï¼Œå¼€å§‹æ¸…ç†...")
        # åœ¨ä¿¡å·å¤„ç†ä¸­ï¼Œæˆ‘ä»¬åªèƒ½æ‰“å°æ¶ˆæ¯ï¼Œå®é™…æ¸…ç†åœ¨ç¨‹åºæ­£å¸¸é€€å‡ºæ—¶è¿›è¡Œ
        print("æ­£åœ¨å…³é—­æœåŠ¡...")
        exit(0)
    
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    
    # å¯åŠ¨Flaskåº”ç”¨
    app.run(host="0.0.0.0", port=8000, debug=False)